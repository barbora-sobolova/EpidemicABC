% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sir_ABC.R
\name{sir.ABC}
\alias{sir.ABC}
\title{ABC for an SIR epidemic model}
\usage{
sir.ABC(
  I.obs,
  n.pop,
  m,
  max.infections = n.pop,
  times = 100,
  max.times = 10000,
  tolerance = 100,
  transf = NULL,
  kern = NULL,
  dist.metr = "euclidean",
  prior = list(lambda.samp = runif, mu.samp = runif, lambda.dens = NULL, mu.dens = NULL),
  importance = list(lambda.samp = NULL, mu.samp = NULL, lambda.dens = NULL, mu.dens =
    NULL),
  prior.params = list(...),
  importance.params = list(...)
)
}
\arguments{
\item{I.obs}{A positive integer valued vector of daily case counts. Days
with zero cases must be included.}

\item{n.pop}{A positive integer specifying the total population size
excluding the initial infectious individuals.}

\item{m}{A positive integer specifying the number of infectious individuals
at the beginning of the epidemic.}

\item{max.infections}{A positive integer specifying the maximum number of 
infections to occur in a single epidemic. If the epidemic tends to generate
more infections, it stops immediately and the proposed particle in the ABC 
algorithm is rejected. Use especially for the ABC algorithm when the 
population is large to reduce the amount of time spent on generating a
single epidemic. The value of maximal infections must be set manually 
regarding the data I.obs.}

\item{times}{A desired size of the sample from the approximate posterior
distribution}

\item{max.times}{A maximal number of iterations}

\item{tolerance}{A positive number specifying the tolerance for accepting 
proposed particles.}

\item{transf}{A function transforming the case count. Must be specified
with one parameters - a case counts vector. The population size and the
number of initial infectious can be used too, since these variables exist
within the 'sir.ABC' function. Their names are 'n.pop' and 'm' 
respectively.}

\item{kern}{A kernel non-negative function, symmetric
around zero, with maximum at zero. Must be specified without any additional 
parameters, i.e. Must be a function of only the value at which we wish to 
evaluate the kernel.}

\item{dist.metr}{Specification of the Mahalanobis distance metric between 
the observed and simulated summary statistic. Must be specified as an 
inverse of a positive definite matrix of the distance metric or the string 
"euclidean". In the latter case, standard euclidean distance is used. 
Use the matrix option only if the dimension of the summary statistics is 
known beforehands!}

\item{prior}{A named list specifying the prior distribution of 'lambda' and 
'mu'. Both distributions are considered independent! Therefore the joint
distribution is a product of the marginals. Must be either of the form:
list(lambda.samp = prior distribution of 'lambda',
mu.samp = prior distribution of 'mu') for the Rejection sampling variant, 
or of the form: list(lambda.samp = prior sampler of 'lambda',
mu.samp = prior sampler of 'mu', lambda.dens = prior density of 'lambda',
mu.dens = prior density of 'mu') for the Importance sampling variant.
In case of the Importance sampling, the sampler and the density functions
accept the same parameters passed from 'prior.params'.}

\item{importance}{A named list specifying the importance distribution of 
'lambda' and 'mu'. Must be of the form: 
list(lambda.dens = importance density of 'lambda',
mu.dens = importance density of 'mu'). The sampler and the density 
functions accept the same parameters passed from 'prior.params'.}

\item{prior.params}{A named list specifying parameters of the prior 
distribution of 'lambda' and 'mu'. These prior parameters are passed to 
the functions specified in the parameter 'prior'. Must be of the form:
list(lambda = c(params for the prior sampler and density of lambda),
mu = c(params for the prior sampler and density of mu)).}

\item{importance.params}{A named list specifying parameters of the 
importance distribution of 'lambda' and 'mu'. These prior parameters are 
passed to the functions specified in the parameter 'importance'. Must be of 
the form: 
list(lambda = c(params for the importance sampler and density of lambda),
mu = c(params for the importance sampler and density of mu)).}
}
\value{
A list consisting of five to seven elements: a numerical matrix containing 
accepted particles, a numerical matrix containing accepted particles
adjusted by the linear regression, a list of summary statistics, total 
number of iterations and number of iterations, which resulted in accepting
the proposed particle. In case of importance sampling, there is an 
additional numerical matrix of importance weights. If a transformation
is used, then list of non-transformed case counts is returned too.
}
\description{
Performs the classic Approximate Bayesian computation algorithm
for the SIR stochastic model.
}
\examples{

transf.sqrt <- function (x) {
 sqrt(x)
}
gse <- gener.sir(lambda = 1.5, mu = 0.5, n.pop = 100, m = 5, 
max.infections = max.infections)
I <- as.vector(table(floor(gse$I)))

# The Importance sampling variant without kernel, with the prior 
# distribution Unif(0.01, 2) for lambda, Unif(0.01, 1.5)  for mu respectively
# and the importance distribution Gamma(2, 2) for both lambda and mu.
# The square root transformation of the case counts is used.
sir.ABC(
  I, 
  n.pop = n.pop, 
  m = m, 
  times = 1e3,
  transf = transf,
  max.times = 2 * 1e4, 
  tolerance = 14,
  kern = NULL,
  prior = c(lambda.samp = runif, mu.samp = runif,
            lambda.dens = dunif, mu.dens = dunif),
  prior.params = list(lambda = c(min = 0.01, max = 2), 
                      mu = c(min = 0.01, max = 1.5)),
  importance = list(lambda.samp = rgamma, mu.samp = rgamma,
                    lambda.dens = dgamma, mu.dens = dgamma),
  importance.params = list(lambda = c(shape = 2, rate = 2),
                            mu = c(shape = 2, rate = 2))
             
# The transformation of the case counts onto the vector with the total size
# of the epidemic as the first element and the total length of the epidemic
# as the second element.
# element
transf.total <- function (x) {
   non.zero <- x != 0
   return(c(sum(x[non.zero]), 
            ifelse(any(non.zero), max(which(non.zero)), 0)))
}
 
# The Rejection sampling variant with a Gaussian kernel, with the prior 
# distribution Unif(0.01, 2) for lambda, Unif(0.01, 1.5)  for mu respectively.  
# The transformation 'transf.total' is used, where we give the double weight
# to the total size (the first element of the summary statistics) by the
# 'dist.metr' parameter.                         
sir.ABC(
  I, 
  n.pop = n.pop, 
  m = m, 
  times = 1e3, max.times = 2 * 1e4,
  tolerance = 350, 
  kern = dnorm,
  dist.metr = diag(c(2, 1)),
  transf = transf.total,
  prior = c(lambda.samp = runif, mu.samp = runif),
  prior.params = list(lambda = c(min = 0.01, max = 2), 
                      mu = c(min = 0.01, max = 1.5))
)

# The Rejection sampling variant with a Gaussian kernel, with the prior 
# distribution Unif(0.01, 2) for lambda, Unif(0.01, 1.5)  for mu respectively.  
# No transformation is used.                      
sir.ABC(
  I, 
  n.pop = n.pop, 
  m = m, 
  times = 1e3, max.times = 2 * 1e4,
  tolerance = 80, 
  kern = dnorm,
  dist.metr = diag(c(2, 1)),
  transf = transf.total,
  prior = c(lambda.samp = runif, mu.samp = runif),
  prior.params = list(lambda = c(min = 0.01, max = 2), 
                      mu = c(min = 0.01, max = 1.5))
)
}
