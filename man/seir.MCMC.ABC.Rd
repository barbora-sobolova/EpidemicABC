% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/seir_MCMC_ABC.R
\name{seir.MCMC.ABC}
\alias{seir.MCMC.ABC}
\title{MCMC-ABC for an SEIR epidemic model}
\usage{
seir.MCMC.ABC(
  I.obs,
  n.pop,
  m,
  max.infections = n.pop,
  times = 100,
  max.init.times = 30,
  burn.in = floor(0.1 * times),
  tolerance = 100,
  transf = NULL,
  kern = NULL,
  dist.metr = "euclidean",
  prior = list(lambda.samp = runif, mu.samp = runif, nu.samp = runif, lambda.dens = NULL,
    mu.dens = NULL, nu.dens = NULL),
  Sigma = diag(c(1, 1, 1)),
  prior.params = list(...)
)
}
\arguments{
\item{I.obs}{a positive integer valued vector of daily (weekly, etc.) case
counts. Days with zero cases must be included.}

\item{n.pop}{the total population size excluding the initial infectious
individuals.}

\item{m}{the number of infectious individuals at the beginning of the
epidemic.}

\item{max.infections}{the maximum number of infections to occur in a single
epidemic. If the epidemic tends to generate considerably more infections
than the observed epidemic, it stops immediately and the proposed
particle in the ABC algorithm is rejected. Use especially for the ABC
algorithm when the  population is large (> 10,000) to reduce the amount
of time spent on generating a single epidemic. The value of maximal
infections must be set manually regarding the data I.obs.}

\item{times}{a desired size of the Markov chain}

\item{burn.in}{the number of iterations to be run before the actual
 Markov chain begins, assuring that the chain converges to the
stationary distribution.}

\item{tolerance}{a positive number specifying the tolerance for accepting
proposed particles.}

\item{transf}{a function transforming the case count. Must be specified
with a single parameter - a case counts vector. If other parameters are
intended to be used in the \code{transf} function (e.g.the population
size, or the number of initial infectious individuals), they must be
defined globally.}

\item{kern}{a kernel function (non-negative , symmetric around zero, with
maximum at zero). Must be specified without any additional parameters,
i.e. Must be a function of only the value at which we wish to evaluate
the kernel.}

\item{dist.metr}{the specification of the Mahalanobis distance metric between
the observed and simulated summary statistic. Must be specified as an
inverse of a positive definite matrix of the distance metric or the
string "euclidean". In the latter case, standard euclidean distance is
used. Use the matrix option only if the dimension of the summary
statistics is known beforehands!}

\item{prior}{a named list specifying the prior distribution of the epidemic
parameters 'lambda' and 'mu'. Both distributions are considered
independent! Therefore the joint distribution is a product of the
marginals. For the exact syntax see the Details section.}

\item{Sigma}{a diagonal positive definite covariance matrix of the Markov 
proposal distribution, which is assumed to be a 3-dimensional Gaussian
with independent marginals.}

\item{prior.params}{a named list specifying parameters of the prior
distribution of 'lambda' and 'mu'. These prior parameters are passed to
the functions specified in the parameter \code{prior}. For the exact
syntax see the Details section.}
}
\value{
a list consisting of five to seven elements:
    \itemize{
        \item \code{accept.parts} a matrix containing the accepted particles
        \item \code{accept.parts.adj} a matrix containing accepted particles
        adjusted by the linear regression
        \item \code{summary.stats} a list of summary statistics
    }
   If a kernel was used, there is also a vector \code{kernel.weights}. If a
   transformation is used, then the list of the non-transformed case counts
   is returned too as the \code{daily.cases.list}.
}
\description{
Performs the Markov chain Approximate Bayesian computation 
algorithm for the SIR stochastic model.
}
\details{
The parameter \code{prior} must be of the form:

\code{list(lambda.samp = prior sampler of 'lambda',
           mu.samp = prior sampler of 'mu',
           lambda.dens = prior density of 'lambda',
           mu.dens = prior density of 'mu')}
}
\examples{
# The transformation of the case counts onto the estimates of the offspring
# mean m.hat and the offspring variance sigma2.hat of the branching process
# approximating the general stochastic epidemic.The estimation uses case
# counts up to the highest point of the epidemic. If this highest point was
# the first day, the epidemic tends to cease very early, which does not
# qualitatively correspond to a longer epidemic, which we often observe (and
# which is in this case simulated using the seed 79). However the offspring
# mean and variance may be within the tolerance region and the proposed
# particle may be accepted. So the summary statistic is set as a sufficiently
# large number, which leads to the rejection.
m <- 5
n.pop <- 1000

transf <- function (x) {
   non.zero <- x != 0
   return(c(sum(x[non.zero]), 
            ifelse(any(non.zero), max(which(non.zero)), 0)))
}
set.seed(79)
gse <- gener.seir(lambda = 0.55, mu = 0.5, n.pop = 1000, m = 5)
I <- as.vector(table(floor(gse$I)))

# The variant without kernel, with the uniform prior distribution
# Unif(0.5, 2), Unif(0.1, 1.5) for 'lambda' and 'mu' respectively.

set.seed(75)
seir.MCMC.ABC(
  I,
  n.pop = n.pop,
  m = m,
  max.infections = 700,
  times = 1e4,
  max.init.times = 30,
  tolerance = 2.5,
  transf = transf,
  prior = c(lambda.samp = runif, mu.samp = runif),
  prior.params = list(lambda = c(min = 0.01, max = 2),
                      mu = c(min = 0.01, max = 1.5)),
  Sigma = diag(c(1, 1, 1))
)

# The variant with the gaussian kernel, with the prior distribution
# Unif(0.5, 2) and Unif(0.1, 1.5) for 'lambda' and 'mu' respectively. No
# transformation is used.
set.seed(76)
sir.MCMC.ABC(
  I,
  n.pop = n.pop,
  m = m,
  max.infections = 700,
  times = 1e4,
  max.init.times = 30,
  tolerance = 100,
  kern = dnorm,
  prior = c(lambda.samp = runif, mu.samp = runif),
  prior.params = list(lambda = c(min = 0.01, max = 2),
                      mu = c(min = 0.01, max = 1.5))
)
}
