% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sir_MCMC_ABC.R
\name{sir.MCMC.ABC}
\alias{sir.MCMC.ABC}
\title{MCMC-ABC for an SIR epidemic model}
\usage{
sir.MCMC.ABC(
  I.obs,
  s0,
  i0,
  max.infections = s0,
  times = 100,
  max.init.times = 30,
  burn.in = floor(0.1 * times),
  tolerance = 100,
  transf = NULL,
  kern = NULL,
  dist.metr = "euclidean",
  prior = list(lambda.samp = runif, mu.samp = runif, lambda.dens = NULL, mu.dens = NULL),
  Sigma = diag(c(1, 1)),
  prior.params = list(...),
  other.mod = NULL,
  other.mod.params = list(...)
)
}
\arguments{
\item{I.obs}{a positive integer valued vector of daily (weekly, etc.) case
counts. Days with zero cases must be included.}

\item{s0}{the total population size excluding the initial infectious
individuals.}

\item{i0}{the number of infectious individuals at the beginning of the
epidemic.}

\item{max.infections}{the maximum number of infections to occur in a single
epidemic. If the epidemic tends to generate considerably more infections
than the observed epidemic, it stops immediately and the proposed
particle in the ABC algorithm is rejected. Use especially for the ABC
algorithm when the  population is large (> 10,000) to reduce the amount
of time spent on generating a single epidemic. The value of maximal
infections must be set manually regarding the data I.obs.}

\item{times}{a desired size of the Markov chain}

\item{burn.in}{the number of iterations to be run before the actual
 Markov chain begins, assuring that the chain converges to the
stationary distribution.}

\item{tolerance}{a positive number specifying the tolerance for accepting
proposed particles.}

\item{transf}{a function transforming the case count. Must be specified
with a single parameter - a case counts vector. If other parameters are
intended to be used in the \code{transf} function (e.g.the population
size, or the number of initial infectious individuals), they must be
defined globally.}

\item{kern}{a kernel function (non-negative , symmetric around zero, with
maximum at zero). Must be specified without any additional parameters,
i.e. Must be a function of only the value at which we wish to evaluate
the kernel.}

\item{dist.metr}{the specification of the Mahalanobis distance metric between
the observed and simulated summary statistic. Must be specified as an
inverse of a positive definite matrix of the distance metric or the
string "euclidean". In the latter case, standard euclidean distance is
used. Use the matrix option only if the dimension of the summary
statistics is known beforehands!}

\item{prior}{a named list specifying the prior distribution of the epidemic
parameters 'lambda' and 'mu'. Both distributions are considered
independent! Therefore the joint distribution is a product of the
marginals. For the exact syntax see the Details section.}

\item{Sigma}{a positive definite covariance matrix of the Markov proposal 
distribution, which is assumed to be a bivariate Gaussian.
#' @param other.mod An alternative function sampling from the model, which 
returns a list with element of infection times \code{I} and logical value
\code{stopped}, which is \code{TRUE} if the \code{max.infections} was
reached. See examples of the \code{sir.ABC} function for more details.}

\item{prior.params}{a named list specifying parameters of the prior
distribution of 'lambda' and 'mu'. These prior parameters are passed to
the functions specified in the parameter \code{prior}. For the exact
syntax see the Details section.}

\item{other.mod.params}{A named lists of parameters supplied to the 
\code{other.mod} function.}
}
\value{
a list consisting of five to seven elements:
    \itemize{
        \item \code{accept.parts} a matrix containing the accepted particles
        \item \code{accept.parts.adj} a matrix containing accepted particles
        adjusted by the linear regression
        \item \code{summary.stats} a list of summary statistics
    }
   If a kernel was used, there is also a vector \code{kernel.weights}. If a
   transformation is used, then the list of the non-transformed case counts
   is returned too as the \code{daily.cases.list}.
}
\description{
Performs the Markov chain Approximate Bayesian computation
algorithm for the SIR stochastic model.
}
\details{
The parameter \code{prior} must be of the form:

\code{list(lambda.samp = sampler of 'lambda', 
           mu.samp = sampler of 'mu', 
           lambda.dens = prior density of 'lambda',
           mu.dens = prior density of 'mu')}
}
\examples{
epi.obs <- c(6, 0, 1, 4, 7, 5, 9, 14, 17, 11, 10, 13, 6, 9, 5, 2, 5, 7, 11, 9,
 12, 19, 13, 12, 13, 16, 19, 10, 19, 19, 7, 12, 11, 11, 9, 10, 10, 13, 18, 5,
 4, 8, 3, 1, 3, 3, 2, 2, 0)

# The variant without kernel, with the uniform prior distribution
# Unif(0.1, 2.5), Unif(0.1, 1.1) for 'lambda' and 'mu' respectively. No
# transformation is used
set.seed(78)
sir.MCMC.ABC(
  I, 
  s0 = s0,
  i0 = i0, times = 2 * 1e4,
  burn.in = 100,
  tolerance = 80,
  prior = c(lambda.samp = runif, mu.samp = runif, 
            lambda.dens = dunif, mu.dens = dunif), 
  prior.params = list(lambda = c(min = 0.01, max = 2),
                      mu = c(min = 0.01, max = 1.5))
)

# The transformation of the case counts onto the vector with the total size
# of the epidemic as the first element and the total length of the epidemic
# as the second element.
# element
transf.total <- function (x) {
   non.zero <- x != 0
   return(c(sum(x[non.zero]), 
            ifelse(any(non.zero), max(which(non.zero)), 0)))
}

# The variant with the gaussian kernel, with the prior distribution
# Unif(0.1, 2.5) and Unif(0.1, 1.5) for 'lambda' and 'mu' respectively. The
# transformation 'transf.total' is used, where we give the double weight
# to the total size (the first element of the summary statistics) by the
# 'dist.metr' parameter.
set.seed(78)
sir.MCMC.ABC(
  I$obs.cases,
  s0 = s0, 
  i0 = i0, 
  times = 2 * 1e4, 
  max.init.times = 30, 
  burn.in = 100, 
  tolerance = 350,
  kern = dnorm,
  dist.metr = diag(c(2, 1)),
  prior = c(lambda.samp = runif, mu.samp = runif, 
            lambda.dens = dunif, mu.dens = dunif),
  prior.params = list(lambda = c(min = 0.1, max = 2.5), 
                      mu = c(min = 0.1, max = 1.1))
 )
}
